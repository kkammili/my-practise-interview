# Problem: Compress Array of Characters

## Description

Given an array of characters `chars`, compress it using the following algorithm:
- For each group of consecutive repeating characters, append the character followed by the group's length if it's more than one.
- Modify the array in-place and return the new length of the array.

### Examples

1. **Input:** `chars = ["a","a","b","b","c","c","c"]`  
   **Output:** Return 6, the array becomes ["a","2","b","2","c","3"]

2. **Input:** `chars = ["a"]`  
   **Output:** Return 1, the array remains ["a"]

3. **Input:** `chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]`  
   **Output:** Return 4, the array becomes ["a","b","1","2"]

### Solution in JavaScript

```javascript
var compress = function(chars) {
    let index = 0;
    let i = 0;

    while (i < chars.length) {
        let j = i;
        while (j < chars.length && chars[j] === chars[i]) {
            j++;
        }
        chars[index++] = chars[i];
        let count = j - i;
        if (count > 1) {
            let countStr = count.toString();
            for (let k = 0; k < countStr.length; k++) {
                chars[index++] = countStr[k];
            }
        }
        i = j;
    }

    return index;
};
```
### Comments
In-Place Modification: The algorithm modifies the array in place without using extra space for another array.
Two-Pointer Technique: Uses two pointers to compress the array by tracking the start of consecutive groups and their lengths.

### Notes
Efficiency: Runs in O(n) time, where n is the number of characters in the input array, with constant space complexity.
Edge Cases: Handles arrays with single characters, mixed groups of varying lengths, and large inputs efficiently.
This solution provides an optimal approach to solve the problem by modifying the input array in-place and using a minimal amount of extra space.